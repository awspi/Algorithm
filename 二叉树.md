# 二叉树

## 基础

![二叉树大纲](https://img-blog.csdnimg.cn/20210219190809451.png)

### 二叉搜索树

二叉搜索树是一个有序树：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树



## [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

### 递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    let res=[];
    const dfs=(root)=>{
        if(root==null) return;
        res.push(root.val);//先序遍历
        dfs(root.left);
        dfs(root.right);
    }
    dfs(root);
    return res;
};
```

### 迭代

前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后**将右孩子加入栈，再加入左孩子,这样出栈的时候才是中左右的顺序**。

![二叉树前序遍历（迭代法）](https://tva1.sinaimg.cn/large/008eGmZEly1gnbmss7603g30eq0d4b2a.gif)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    let res=[];
    if(!root) return res;
    const stack=[];
    stack.push(root);//根节点进栈
    while(stack.length){
        let cur=stack.pop()//中间节点出栈
        res.push(cur.val);
        cur.right&&stack.push(cur.right);//右入栈
        cur.left&&stack.push(cur.left);//左入栈
    }
    return res;
};
```

前序遍历，发现取出一个栈顶元素，使其局部前序入栈后，栈顶元素依然是此元素，接着就要出栈输出了，所以使其随局部入栈是没有必要的

## [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

### 递归

```js
		const dfs=(root)=>{
        if(root==null) return;
        dfs(root.left);
        dfs(root.right);
        res.push(root.val);//后序遍历
    }
```

### 迭代

(在前序基础上修改)

先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：

![20200808200338924](https://img-blog.csdnimg.cn/20200808200338924.png)

```js

var postorderTraversal = function(root) {
let res=[];
    if(!root) return res;
    const stack=[];
    stack.push(root);//根节点进栈
    while(stack.length){
        let cur=stack.pop()//中间节点出栈
        res.push(cur.val);
        cur.left&&stack.push(cur.left);//左入栈  //颠倒顺序, 中右左
        cur.right&&stack.push(cur.right);//右入栈 
        
    }
    return res.reverse(); //翻转变成左右中
};
```



## [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

### 递归

```js
		const dfs=(root)=>{
        if(root==null) return;
        dfs(root.left);
        res.push(root.val);//中序遍历
        dfs(root.right);
    }
```

### 迭代

(与前后序处理方式不一致 )

中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**

那么**在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。**

![二叉树中序遍历（迭代法）](https://tva1.sinaimg.cn/large/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    let res=[];
    let stack=[];
    let cur=root;
    while(cur!=null||stack.length!=0){
        if(cur!==null){
            stack.push(cur);
            cur=cur.left;//左节点
        }else{//到底了
            cur=stack.pop();//弹出 中
            res.push(cur.val);//cur.val
            cur=cur.right;//右
        }
    }
    return res
};
```

## 144 145 95 统一格式迭代

*非递归遍历统一格式**https://blog.csdn.net/qq_36459536/article/details/80385886*

**将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**

如何标记呢，**就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。**

![中序遍历迭代（统一写法）](https://tva1.sinaimg.cn/large/008eGmZEly1gnbmq3btubg30em09ue82.gif)

可以看出我们将访问的节点直接加入到栈中，但如果**是处理的节点则后面放入一个空节点**， **这样只有空节点弹出的时候，才将下一个节点放进结果集。**

> 中序遍历统一迭代法

```js
//  中序遍历：左中右
//  压栈顺序：右中左
 
var inorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {
            res.push(stack.pop().val);
            continue;
        }
        if (node.right) stack.push(node.right); // 右
        stack.push(node); // 中
        stack.push(null);
        if (node.left) stack.push(node.left); // 左
    };
    return res;
};
```

> 前序遍历统一迭代法

```js
// 前序遍历：中左右
// 压栈顺序：右左中

var preorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {//node==null
            res.push(stack.pop().val);
            continue;
        }
        if (node.right) stack.push(node.right); // 右
        if (node.left) stack.push(node.left); // 左
        stack.push(node); // 中
        stack.push(null);
    };
    return res;
};
```



> 后序遍历统一迭代法

```js
// 后续遍历：左右中
// 压栈顺序：中右左
 
var postorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {
            res.push(stack.pop().val);
            continue;
        }
        stack.push(node); // 中
        stack.push(null);
        if (node.right) stack.push(node.right); // 右
        if (node.left) stack.push(node.left); // 左
    };
    return res;
};
```

## [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

**BFS** 遍历使用**队列**数据结构

截取 BFS 遍历过程中的某个时刻：



可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，我们无法区分队列中的结点来自哪一层。

![BFS 遍历中某个时刻队列的状态](https://pic.leetcode-cn.com/9f178b56ff1c94388d893f2fb48e9e77e186aba7cfd7483637776359062d68b8.jpg)

因此，我们需要稍微修改一下代码，**在每一层遍历开始前，先记录队列中的结点数量 n**（也就是这一层的结点数量），然后一口气处理完这一层的 n 个结点。

*https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/*

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if(root==null) return [];

    let res=[],queue=[];
    queue.push(root);

    while(queue.length){
        let curlevel=[]; // 记录当前层级节点
        let queueLen=queue.length//  queueLen不然下面queue.shift会让length-1
        for(let i=0;i<queueLen;i++){//把当前层级节点全出队列
            let node=queue.shift();
            curlevel.push(node.val);
          
            //如果该节点存在左右子节点,直接加入队列,不用担心层次,
          //因为queueLen记录了当层节点数,出完了就进行下一层的遍历了
            node.left&&queue.push(node.left)
            node.right&&queue.push(node.right)
        }
        res.push(curlevel);
    }
    return res;
};
```



## [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {//BFS只加入右节点,队列每次只出一个
    if(root==null) return [];
    let queue=[];//总队列
    let res=[];
    queue.push(root);
    //队列每次只出一个 不需要计数
    while(queue.length){
        let node =queue.shift();
        res.push(node.val);
        node.right&&queue.push(node.right);
    }
    return res;
};
```



## [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

看清题意,二叉树右视图 只需要把每一层最后一个节点存储到res数组

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {//二叉树右视图 只需要把每一层最后一个节点存储到res数组
    if(root==null) return [];
    let queue=[];//总队列
    queue.push(root);
    
    let res=[];
    
    while(queue.length){
        let queueLen=queue.length;
        while(queueLen--){
            let node=queue.shift()
            if(queueLen==0){
                res.push(node.val)//每层的最后一个
            }
            node.left&&queue.push(node.left);
            node.right&&queue.push(node.right);
    }
        }

    return res;
};
```



## [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

102 求每层平均值

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var averageOfLevels = function(root) {//非空二叉树的
    let queue=[],res=[];
    queue.push(root);
    while(queue.length){
        let len=queue.length;
        let curSum=0;
        for(let i=0;i<len;i++){
            let node=queue.shift();
            curSum+=node.val;
            node.left&&queue.push(node.left);
            node.right &&queue.push(node.right);
        }
        res.push(curSum/len);
    }
    return res;
};
```



## [429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

每一层可能有2个以上,所以不再使用node.left node.right  而是循坏node.children

```js
/**
 * // Definition for a Node.
 * function Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

/**
 * @param {Node|null} root
 * @return {number[][]}
 */
var levelOrder = function(root) {// //每一层可能有2个以上,所以不再使用node.left node.right
    if(root==null) return [];
    let queue=[];
    let res=[];
    queue.push(root);
    while(queue.length){
        let len=queue.length;
        let curLevel=[];
        while(len--){
            let node=queue.shift();
            curLevel.push(node.val);
            //这里不再是 ndoe.left node.right 而是循坏node.children
            for(const item of node.children){
                item&&queue.push(item)
            }
        }
        res.push(curLevel);
    }
    return res;
};
```



## [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var largestValues = function(root) {//BFS
if(root==null) return [];
    let queue=[];
    let res=[];
    queue.push(root);
    while(queue.length){
        let len=queue.length;
        let max=-Infinity;
        while(len--){
            let node=queue.shift();
            max=Math.max(max,node.val);

            node.left&&queue.push(node.left);
            node.right&&queue.push(node.right);
        }
        res.push(max);
    }
    return res;
};
```



## [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

```js
/**
 * // Definition for a Node.
 * function Node(val, left, right, next) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.next = next === undefined ? null : next;
 * };
 */

/**
 * @param {Node} root
 * @return {Node}
 */
var connect = function(root) {
    if(root==null) return root;
    let queue=[];
    queue.push(root);
    while(queue.length){
        let len=queue.length;
        for(let i=0;i<len;i++){
            let node=queue.shift();
            ////初始状态下，所有 next 指针都被设置为 NULL。 最右本身就->null不用管
            if(i<len-1)node.next=queue[0];
            //[0,1,2]0先被shift,queue变成[1,2],想让0指向右边的1,让他=queue[0]
            node.left&&queue.push(node.left);
            node.right&&queue.push(node.right);

        }
    }
    return root;
};
```



## [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

```js
/**
 * // Definition for a Node.
 * function Node(val, left, right, next) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.next = next === undefined ? null : next;
 * };
 */

/**
 * @param {Node} root
 * @return {Node}
 */
var connect = function(root) {
    if(root==null) return root;
    let queue=[];
    queue.push(root);
    while(queue.length){
        let len=queue.length;
        for(let i=0;i<len;i++){
            let node=queue.shift();
            if(i<len-1) node.next=queue[0]//如果queue[0]不存在,也是null
            
            node.left&&queue.push(node.left);
            node.right&&queue.push(node.right);
        }
    }
    return root;
};
```



## [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

**DFS递归**

```js
var maxDepth = function(root) {
    const dfs=(node)=>{
        if(node==null) return 0;
        return Math.max(dfs(node.left),dfs(node.right))+1;
    }
    return dfs(root);
};
```

**BFS**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {//BFS
   if(root==null) return 0;
    let queue=[];
    let depth=0;
    queue.push(root);
    while(queue.length){
        let len=queue.length;
        for(let i=0;i<len;i++){
            let node=queue.shift();
            
            node.left&&queue.push(node.left);
            node.right&&queue.push(node.right);
        }
        depth++;
    }
    return depth;

};
```





## [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)



**BFS**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if(root==null) return 0;
    let queue=[];
    let depth=0;
    queue.push(root);
    while(queue.length){
        let len=queue.length;
        depth++;
        while(len--){
            let node=queue.shift();
            // // 如果左右节点都是null，则该节点深度最小
            if(node.left==null&&node.right==null) return depth;
            node.left&&queue.push(node.left);
            node.right&&queue.push(node.right);
        }
    }
    return depth;//这里随便返回啥都行,不会运行到这的
};
```

**DFS遍历**

代码简单不太好思考,不如BFS

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    const dfs=(node)=>{
        if(node==null) return 0;
        if(node.left==null&&node.right==null){//都不存在,到底了
            return 1;
        }else if(node.left&&node.right==null){//左节点存在
            return dfs(node.left)+1;
        }else if(node.left==null&&node.right){//右节点存在
            return dfs(node.right)+1;
        }else if(node.left&&node.right){//都存在
            return Math.min(dfs(node.left),dfs(node.right))+1;
        }
    }
    return dfs(root);
};
```





## [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

DFS先序遍历 递归实现

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {//先序遍历 递归实现
  const invertNode=(root)=>{
    if(root==null) return root;
    [root.left,root.right]=[root.right,root.left];
    invertNode(root.left);
    invertNode(root.right);
    return root;
  }
  return invertNode(root);

};
```

BFS

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {//BFS
  if(root==null) return root;
  let queue =[];
  queue.push(root);


  while(queue.length){
    let len=queue.length;
    while(len--){
      let node=queue.shift();//层次遍历到一个节点,就把他的子节点颠倒
      [[node.left],[node.right]]=[[node.right],[node.left]];
      node.left&&queue.push(node.left);
      node.right&&queue.push(node.right);
    }
  }
  return root;
};
```



## [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

### 思路

**首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！**

对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了**其实我们要比较的是两个树（这两个树是根节点的左右子树）**，所以在递归遍历的过程中，也是要同时遍历两棵树。

那么如何比较呢？

比较的是两个子树的里侧和外侧的元素是否相等。如图所示：

![101. 对称二叉树1](https://img-blog.csdnimg.cn/20210203144624414.png)

从根节点的左子树与右子树开始,类似于后续遍历,先左子树的左节点,再右子树的右节点,最后比较节点自身val是否相等

递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
      const compare=(left,right) =>{
    if (left == null && right == null) {
      return true;
    }
    if (left == null || right == null) {
      return false;
    }
    //剩下的非空节点
    if (left.val != right.val) {
      return false;
    }
    
    //此时就是：左右节点都不为空，且数值相同的情况
    let outside=compare(left.left,right.right);
    let inside=compare(left.right,right.left);
    return outside&&inside; //都相等返回true
  }
  if(root==null) return true;
  return compare(root.left,root.right);
};
```

哪错了

```
var isSymmetric = function(root) {
const compare=(left,right) =>{
    if(left ==null && right ==null) {return true;}
    else if(left!==null && right==null) {return false;}
    else if(left==null && right!==null) {return false;}
    //剩下的非空节点
    else if(left.value!=right.value) {return false;}
    //此时就是：左右节点都不为空，且数值相同的情况
    let outside=compare(left.left,right.right);
    let inside=compare(left.right,right.left);
    return outside&&inside; //都相等返回true
  }
  if(root==null) return true;
  return compare(root.left,root.right);
};
```





这道题目我们也可以使用迭代法，但要注意，这里的迭代法可不是前中后序的迭代写法，因为本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓二叉树遍历的前中后序的关系了。

这里我们可以使用队列来比较两个树（根节点的左右子树）是否相互翻转，（**注意这不是层序遍历**）

通过队列来判断根节点的左子树和右子树的内侧和外侧是否相等，如动画所示：

![101.对称二叉树](https://tva1.sinaimg.cn/large/008eGmZEly1gnwcimlj8lg30hm0bqnpd.gif)

**队列**实现迭代判断是否为对称二叉树：

```js
var isSymmetric = function(root) {//队列
  if(root==null) return true;
  let queue=[];
  queue.push(root.left); 
  queue.push(root.right);
  while(queue.length){
    let left = queue.shift();
    let right=queue.shift();
    if(left==null&&right==null){
      continue;//都为null跳过
    }
    if(left==null||right==null||left.val!=right.val){
      return false;
    }

    //push的时候可能把为null的节点push进去了
    queue.push(left.left)
    queue.push(right.right)

    queue.push(left.right)
    queue.push(right.left)
    
  }
  return true;
};
```

用栈实现也是差不多



## [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {

  const compare=(p,q)=>{
    if(p==null&&q==null) return true;
    if(p==null||q==null||p.val!=q.val) return false;
    
    //剩下的就是p.val==q.val的情况
    // if(p.val==q.val) return true;
    let left=compare(p.left,q.left);
    let right=compare(p.right,q.right);
    return left&&right;//都相等返回true
    
  }
  return compare(p,q);

};
```



## [572. 另一棵树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} subRoot
 * @return {boolean}
 */
var isSubtree = function(root, subRoot) {
    if(root==null) return subRoot==null;//如果root为null,sub也为空返回true

  const compare=(p,q)=>{
    if(p==null&&q==null) return true;
    if(p==null||q==null||p.val!=q.val) return false;
    
    //剩下的就是p.val==q.val的情况
    // if(p.val==q.val) return true;
    let left=compare(p.left,q.left);
    let right=compare(p.right,q.right);
    return left&&right;//都相等返回true
  }

  if(compare(root,subRoot)) return true;
    return isSubtree(root.left,subRoot)||isSubtree(root.right,subRoot)
  
};
```



## [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

### 思路

1.当成普通二叉树

1. 确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回以该节点为根节点二叉树的节点数量，所以返回值为int类型。

   ```js
   let getNodeNum=(node)=>{}
   ```

   

2. 确定终止条件：如果为空节点的话，就返回0，表示节点数为0。

   ```js
     if(node==null) return 0;
   ```

   

3. 确定单层递归的逻辑：先求它的左子树的节点数量，再求的右子树的节点数量，最后取总和再加一 （加1是因为算上当前中间节点）就是目前节点为根节点的节点数量。

   ```js
      let left=getNodeNum(node.left);
           let right=getNodeNum(aode.right);
           return left+right+1;
   ```

   

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function(root) {
    let getNodeNum=(node)=>{
        if(node==null) return 0;
        let left=getNodeNum(node.left);
        let right=getNodeNum(node.right);
        return left+right+1;
    }

    return getNodeNum(root);
};
```



思路2:

完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满且向左停靠。

如果根节点的左子树深度等于右子树深度，则说明左子树为满二叉树 

如果根节点的左子树深度大于右子树深度，则说明右子树为满二叉树

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function(root) { //利用性质 全二叉树的节点个数2*h-1
    if(root==null) return 0;
    let left=0,right=0;
    let cur=root;
    while(cur!=null){
        left++;
        cur=cur.left;
    }
    cur =root;
    while(cur!=null){
        right++;
        cur=cur.right;
    }
    if(left==right){
        return 2**left-1;
    }
    return countNodes(root.left)+countNodes(root.right)+1;//加1是根节点
};
```



## [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

![20210203155515650](https://img-blog.csdnimg.cn/20210203155515650.png)

leetcode的题目中都是以节点为一度，即根节点深度是1。



**明确递归函数的参数和返回值**

参数：当前传入节点。
返回值：以当前传入节点为根节点的树的高度。

那么如何标记左右子树是否差值大于1呢？

如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。

所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。



**明确终止条件**

递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为0



**明确单层递归的逻辑**

如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。

分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则则返回-1，表示已经不是二叉平衡树了。

**代码:**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
    const getHeight=(node)=>{
        if(node==null) return 0;
        let left=getHeight(node.left);
        if(left==-1) return -1;
        let right=getHeight(node.right);
        if(right==-1) return -1;

        let diff=Math.abs(left-right);
        //以当前节点为根节点的树的最大高度
        return diff<=1?Math.max(left,right)+1:-1;
    }
    return getHeight(root)==-1?false:true;
};
```



改造104最大深度也可以



```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
    const dfs=(node)=>{
        if(node==null) return 0;
        return Math.max(dfs(node.left),dfs(node.right))+1;
    }
    if(root==null)return true;
    return Math.abs(dfs(root.left)-dfs(root.right))<=1&&isBalanced(root.left)&&isBalanced(root.right);
};
```



## [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

这道题目要求从**根节点到叶子的路径**，**所以需要前序遍历，这样才方便让父节点指向孩子节点**，找到对应的路径。

在这道题目中将第一次涉及到回溯，因为我们要** **，需要回溯来回退一一个路径在进入另一个路径。

前序遍历以及回溯的过程如图：

![257.二叉树的所有路径](https://img-blog.csdnimg.cn/20210204151702443.png)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {string[]}
 */
var binaryTreePaths = function(root) {//递归+回溯
    let res=[];
    //1.递归函数函数参数以及返回值
    const traversal=(node,curPath)=>{
        //2.确定递归终止条件
        if(!node.left&&!node.right){
            curPath+=node.val;
            res.push(curPath);
            return;
        }
        // 3.确定单层递归逻辑
        //回溯和递归是一一对应的，有一个递归，就要有一个回溯
        curPath+=node.val+'->';
        node.left&&traversal(node.left,curPath);//回溯 每次函数调用完，path依然是没有加上"->" 的，这就是回溯了。
        node.right&&traversal(node.right,curPath);//回溯
    }
        traversal(root,'');
        return res;
     
};
```



## [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

BFS

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var findBottomLeftValue = function(root) {
    let queue=[];
    let res=0;
    queue.push(root);
    while(queue.length){
        let len=queue.length;//len是每一层节点的个数
        res=queue[0].val;//每次循环都更新res为当前层次最左的节点
        while(len--){
            let node=queue.shift();
            node.left&&queue.push(node.left);
            node.right&&queue.push(node.right);
        }
    }
    return res;

};
```

递归回溯

**如果需要遍历整棵树，递归函数就不能有返回值。如果需要遍历某一条固定路线，递归函数就一定要有返回值！**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var findBottomLeftValue = function(root) {
    let maxDepth=-1;
    let res;
    const traversal=(node,curDepth)=>{
        if(!node) return null;
        if(curDepth>maxDepth){ //curDepth记录的是当前的层次
            maxDepth=curDepth;
            res=node.val;//每次一定是左节点先到下一层
        }
        traversal(node.left,curDepth+1);//回溯 一定要先左后右
        traversal(node.right,curDepth+1);
    }
    traversal(root,0);
    return res;
};
```



## [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

**首先要注意是判断左叶子，不是二叉树左侧节点，所以不是层序遍历。**

**如果左节点不为空，且左节点没有左右孩子，那么这个节点的左节点就是左叶子**

![20210204151949672](https://img-blog.csdnimg.cn/20210204151949672.png)

图中二叉树，左叶子之和究竟是0

判断当前节点是不是左叶子是无法判断的，**必须要通过节点的父节点**来判断其左孩子是不是左叶子

当遇到左叶子节点的时候，记录数值，
然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumOfLeftLeaves = function(root) {
  //判断一个树的左叶子节点之和，那么一定要传入树的根节点，
    const traversal=(node)=>{
        if(node==null) return 0;
       
        // 当遇到左叶子节点的时候，记录数值，
        //然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。
        let leftVal=traversal(node.left);
        let rightVal=traversal(node.right);

        let curVal=0;
        if(node.left&&!node.left.left&&!node.left.right){//当前节点的左节点是叶子节点的话
            curVal=node.left.val
        }
      //递归函数的返回值为数值之和
        return curVal+leftVal+rightVal
    }
    return traversal(root);
};
```





## [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

这道题我们要遍历从根节点到叶子节点的的路径看看总和是不是目标和。

可以使用深度优先遍历的方式（本题前中后序都可以，无所谓，因为中节点也没有处理逻辑）来遍历二叉树

1.确定递归函数的参数和返回类型

参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和

再来看**返回值**，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

- 如果需要**搜索整棵二叉树且不用处理递归返回值**，递归函数就不要返回值。（113.路径总和ii）
- 如果需要**搜索整棵二叉树且需要处理递归返回值**，递归函数就需要返回值。 （236. 二叉树的最近公共祖先 (opens new window)）
- 如果要**搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回**。（本题的情况）

而本题我们要找一条符合条件的路径，所以递归函数需要返回值，及时返回，那么返回类型是什么呢？

如图所示：

![112.路径总和](https://img-blog.csdnimg.cn/2021020316051216.png)

图中可以看出，遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用bool类型表示。

2.确定终止条件

首先计数器如何统计这一条路径的和呢？

不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以**用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。**

- 如果**最后count == 0，同时到了叶子节点的话，说明找到了目标和**。
- 如果**遍历到了叶子节点，count不为0，就是没找到。**

3.确定单层递归的逻辑

**因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归了。**

递归函数是有返回值的，如果递归函数返回true，说明找到了合适的路径，应该立刻返回。



```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {
    let traversal=(node,sum)=>{
        if(!node.left&&!node.right&&sum==0) return true;// 遇到叶子节点，并且计数为0
        if(!node.left&&!node.right) return false;// // 遇到叶子节点而没有找到合适的边，直接返回

        if(node.left){
            if(traversal(node.left,sum-node.left.val)) return true;
          //因为把sum - node.left->val 直接作为参数传进去，函数结束，count的数值没有改变。
        }
      //效果一样,代码更简洁
      	if(node.right&&traversal(node.right,sum-node.right.val)) return true;
        return false;//都不行,回到最初,给个结果,不然没返回值
    }
    if(root==null) return false;
    return(traversal(root,targetSum-root.val))////开始targetSum要先减掉根节点的值
};
```

## [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {number[][]}
 */
var pathSum = function(root, targetSum) {//返回路径
    let res=[];
    const traversal=(node,sum,path)=>{
        if(!node.left&&!node.right&&sum==0) { // 遇到了叶子节点且找到了和为sum的路径
            res.push([...path]);// 不能写res.push(path), 要深拷贝
            return;
        }
        if(!node.left&&!node.right) return;// 遇到叶子节点而没有找到合适的边，直接返回

        if(node.left){// 左 （空节点不遍历）
            path.push(node.left.val);
            traversal(node.left,sum-node.left.val,path)// 递归
            path.pop();// 回溯
        }
        if(node.right){// 右 （空节点不遍历）
            path.push(node.right.val);
            traversal(node.right,sum-node.right.val,path)// 递归
            path.pop();// 回溯
        }
        return;
    }
    if(root==null) return res;
    traversal(root,targetSum-root.val,[root.val])//开始要加上根节点
    return res;

};
```



**隐性回溯**

```js

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {number[][]}
 */
var pathSum = function(root, targetSum) {
    if(root==null) return [];
    let res=[];

    const DFS=(node,sum,path)=>{

        if(!node.left&&!node.right&&sum==0){//如果为叶子节点,递归出口
            res.push([...path]);//add an array
            return;
        }
				//若有左节点,递归左子树
        node.left&&DFS(node.left,sum-node.left.val,[...path,node.left.val])//传参 隐式回溯
        node.right&&DFS(node.right,sum-node.right.val,[...path,node.right.val])

    }
    DFS(root,targetSum-root.val,[root.val]);
    return res;
};
```



## [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)





![106.从中序与后序遍历序列构造二叉树](https://img-blog.csdnimg.cn/20210203154249860.png)

- 第一步：如果数组大小为零的话，说明是空节点了。
- 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。
- 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点
- 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）
- 第五步：切割后序数组，切成后序左数组和后序右数组
- 第六步：递归处理左区间和右区间

1. 后序遍历最后一位为根节点的值，pop后，postorder剩 左子树 + 右子树
2. 1得的值，切中序遍历的数组，inorder两侧为 左子树 + 右子树
3. 1的左子树与2的左子树，1的右子树与2的右子树，分别递归



```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function(inorder, postorder) {
    if(!inorder.length) return null;

    let rootval=postorder.pop();// 从后序遍历的数组中获取中间节点的值， 即数组最后一个值
    let rootIndex=inorder.indexOf(rootval);// 获取中间节点在中序遍历中的下标
  
    const root = new TreeNode(rootval);// 创建中间节点
  
    root.left= buildTree(inorder.slice(0,rootIndex),postorder.slice(0,rootIndex)) // 创建左节点
    root.right=buildTree(inorder.slice(rootIndex+1),postorder.slice(rootIndex)) // 创建右节点 ????
    return root;
};
```

## [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

**思路**

```
preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
首先根据 preorder 找到根节点是 3
    
然后根据根节点将 inorder 分成左子树和右子树
左子树
inorder [9]

右子树
inorder [15,20,7]

把相应的前序遍历的数组也加进来
左子树
preorder[9] 
inorder [9]

右子树
preorder[20 15 7] 
inorder [15,20,7]

现在我们只需要构造左子树和右子树即可，成功把大问题化成了小问题
然后重复上边的步骤继续划分，直到 preorder 和 inorder 都为空，返回 null 即可

```



```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
    if(!preorder.length) return null;

    let rootval=preorder.shift();// 从先序遍历的数组中获取中间节点的值， 即数组最后一个值
    let rootIndex=inorder.indexOf(rootval);// 获取中间节点在中序遍历中的下标
  
    const root = new TreeNode(rootval);// 创建中间节点
  
    root.left= buildTree(preorder.slice(0,rootIndex),inorder.slice(0,rootIndex)) // 创建左节点
    root.right=buildTree(preorder.slice(rootIndex),inorder.slice(rootIndex+1)) // 创建右节点
    return root;


};
```

**解法二：递归简便版**

https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/105-cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou--6/

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
    let build = (inorder) => {
        if(!inorder || !inorder.length) return null
        let tmp = preorder.shift(),mid = inorder.indexOf(tmp)
        let root = new TreeNode(tmp)
        root.left = build(inorder.slice(0,mid))
        root.right = build(inorder.slice(mid + 1))
        return root
    }
    return build(inorder)
};

```





## [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var constructMaximumBinaryTree = function(nums) {
    if(nums.length==0) return null;
    let maxNum=Math.max(...nums);
    let maxIndex=nums.indexOf(maxNum);

    return new TreeNode(maxNum,
    constructMaximumBinaryTree(nums.slice(0,maxIndex)),
    constructMaximumBinaryTree(nums.slice(maxIndex+1)));

};
```



## [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

**前序遍历,修改树的结构**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */
var mergeTrees = function(root1, root2) {
    const traversal=(t1,t2)=>{
        if(!t1) return t2;
        if(!t2) return t1;
        
        t1.val+=t2.val;

        t1.left=traversal(t1.left,t2.left);
        t1.right=traversal(t1.right,t2.right);
      
       
				//中序,或者后序都行
        //t1.left=traversal(t1.left,t2.left);
      	//t1.val+=t2.val;
       	//t1.right=traversal(t1.right,t2.right);

        return t1;
    }
    return traversal(root1,root2);
};
```

**不修改结构**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */
var mergeTrees = function(root1, root2) {
    const traversal=(t1,t2)=>{
        // 合并节点,如果一个不存在,就不用求和,直接返回另一个就可以
        if(!t1) return t2;
        if(!t2) return t1;
      	
      //定义新节点
        let node=new TreeNode(0);
        node.val= t1.val+t2.val;

        node.left=traversal(t1.left,t2.left);
        node.right=traversal(t1.right,t2.right);

        return node;
;
    }
    return traversal(root1,root2);
};
```



## [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

![二叉搜索树](https://img-blog.csdnimg.cn/20200812190213280.png)

二叉搜索树是一个有序树：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树

递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} val
 * @return {TreeNode}
 */
var searchBST = function(root, val) {
    const DFS=(node,val)=>{
        if(node==null||node.val==val) return node;//顺序:先if ==null,不然null就没有.val

        //如果root.val > val，搜索左子树，如果root.val < val，就搜索右子树，最后如果都没有搜索到，就返回NULL。
        if(node.val>val) return DFS(node.left,val);
        if(node.val<val) return DFS(node.right,val);

        return null;
    }
    return DFS(root,val);
};
```

**迭代法**

```js
    /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
    /**
    * @param {TreeNode} root
    * @param {number} val
    * @return {TreeNode}
    */
    var searchBST = function(root, val) {
        while(root){
            if(root.val>val){
                root=root.left;
            }else if(root.val<val){
                root=root.right;
            }else{
                break;
            }
        }
        return root;
    };
```



## [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
    let preNode=null;//声明一个变量来存储上一个节点
    const DFS=(node)=>{
        if(!node) return true;

        if(!DFS(node.left)) return false;//// 判断左侧节点是否满足条件，满足条件继续执行

        // 如果前节点小于等于上一次节点的val值 说明不是递增的 就返回false
        if(preNode&&node.val<=preNode.val) return false//模拟前几个理解
        preNode=node;  // 中序遍历更新节点值

        return DFS(node.right)// 返回右边节点的检测结果
    }
    return DFS(root);
};
```



## [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

**转化成升序数组做**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var getMinimumDifference = function(root) {
    let arr=[];
    const DFS=(node)=>{//转为升序数组
        if(!node) return;
        DFS(node.left);
        arr.push(node.val);
        DFS(node.right);
    }
    DFS(root);
    
    if(arr.length<2) return 0;
    let diff=arr[1]-arr[0];
    for(let i=1;i<arr.length;i++){// 统计有序数组的最小差值
        diff=Math.min(diff,arr[i]-arr[i-1]);
    }
    return diff;
    
};
```

**递归 在递归的过程中更新最小值**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var getMinimumDifference = function(root) {
    let res=Infinity;
    let preNode=null;
    const inorder=(node)=>{
        if(!node) return;
        inorder(node.left);
        if(preNode)res=Math.min(res,node.val-preNode.val);

        preNode=node;
        inorder(node.right);
    }
    inorder(root);
    return res;
};
```

