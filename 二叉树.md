# 二叉树

## 基础

![二叉树大纲](https://img-blog.csdnimg.cn/20210219190809451.png)



## [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

### 递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    let res=[];
    const dfs=(root)=>{
        if(root==null) return;
        res.push(root.val);//先序遍历
        dfs(root.left);
        dfs(root.right);
    }
    dfs(root);
    return res;
};
```

### 迭代

前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后**将右孩子加入栈，再加入左孩子,这样出栈的时候才是中左右的顺序**。

![二叉树前序遍历（迭代法）](https://tva1.sinaimg.cn/large/008eGmZEly1gnbmss7603g30eq0d4b2a.gif)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    let res=[];
    if(!root) return res;
    const stack=[];
    stack.push(root);//根节点进栈
    while(stack.length){
        let cur=stack.pop()//中间节点出栈
        res.push(cur.val);
        cur.right&&stack.push(cur.right);//右入栈
        cur.left&&stack.push(cur.left);//左入栈
    }
    return res;
};
```

前序遍历，发现取出一个栈顶元素，使其局部前序入栈后，栈顶元素依然是此元素，接着就要出栈输出了，所以使其随局部入栈是没有必要的

## [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

### 递归

```js
		const dfs=(root)=>{
        if(root==null) return;
        dfs(root.left);
        dfs(root.right);
        res.push(root.val);//后序遍历
    }
```

### 迭代

(在前序基础上修改)

先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：

![20200808200338924](https://img-blog.csdnimg.cn/20200808200338924.png)

```js

var postorderTraversal = function(root) {
let res=[];
    if(!root) return res;
    const stack=[];
    stack.push(root);//根节点进栈
    while(stack.length){
        let cur=stack.pop()//中间节点出栈
        res.push(cur.val);
        cur.left&&stack.push(cur.left);//左入栈  //颠倒顺序, 中右左
        cur.right&&stack.push(cur.right);//右入栈 
        
    }
    return res.reverse(); //翻转变成左右中
};
```



## [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

### 递归

```js
		const dfs=(root)=>{
        if(root==null) return;
        dfs(root.left);
        res.push(root.val);//中序遍历
        dfs(root.right);
    }
```

### 迭代

(与前后序处理方式不一致 )

中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**

那么**在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。**

![二叉树中序遍历（迭代法）](https://tva1.sinaimg.cn/large/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    let res=[];
    let stack=[];
    let cur=root;
    while(cur!=null||stack.length!=0){
        if(cur!==null){
            stack.push(cur);
            cur=cur.left;//左节点
        }else{//到底了
            cur=stack.pop();//弹出 中
            res.push(cur.val);//cur.val
            cur=cur.right;//右
        }
    }
    return res
};
```

## 144 145 95 统一格式迭代

*非递归遍历统一格式**https://blog.csdn.net/qq_36459536/article/details/80385886*

**将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**

如何标记呢，**就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。**

![中序遍历迭代（统一写法）](https://tva1.sinaimg.cn/large/008eGmZEly1gnbmq3btubg30em09ue82.gif)

可以看出我们将访问的节点直接加入到栈中，但如果**是处理的节点则后面放入一个空节点**， **这样只有空节点弹出的时候，才将下一个节点放进结果集。**

> 中序遍历统一迭代法

```js
//  中序遍历：左中右
//  压栈顺序：右中左
 
var inorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {
            res.push(stack.pop().val);
            continue;
        }
        if (node.right) stack.push(node.right); // 右
        stack.push(node); // 中
        stack.push(null);
        if (node.left) stack.push(node.left); // 左
    };
    return res;
};
```

> 前序遍历统一迭代法

```js
// 前序遍历：中左右
// 压栈顺序：右左中

var preorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {//node==null
            res.push(stack.pop().val);
            continue;
        }
        if (node.right) stack.push(node.right); // 右
        if (node.left) stack.push(node.left); // 左
        stack.push(node); // 中
        stack.push(null);
    };
    return res;
};
```



> 后序遍历统一迭代法

```js
// 后续遍历：左右中
// 压栈顺序：中右左
 
var postorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {
            res.push(stack.pop().val);
            continue;
        }
        stack.push(node); // 中
        stack.push(null);
        if (node.right) stack.push(node.right); // 右
        if (node.left) stack.push(node.left); // 左
    };
    return res;
};
```

## [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

**BFS** 遍历使用**队列**数据结构

截取 BFS 遍历过程中的某个时刻：



可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，我们无法区分队列中的结点来自哪一层。

![BFS 遍历中某个时刻队列的状态](https://pic.leetcode-cn.com/9f178b56ff1c94388d893f2fb48e9e77e186aba7cfd7483637776359062d68b8.jpg)

因此，我们需要稍微修改一下代码，**在每一层遍历开始前，先记录队列中的结点数量 n**（也就是这一层的结点数量），然后一口气处理完这一层的 n 个结点。

*https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/*

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if(root==null) return [];

    let res=[],queue=[];
    queue.push(root);

    while(queue.length){
        let curlevel=[]; // 记录当前层级节点
        let queueLen=queue.length//  queueLen不然下面queue.shift会让length-1
        for(let i=0;i<queueLen;i++){//把当前层级节点全出队列
            let node=queue.shift();
            curlevel.push(node.val);
          
            //如果该节点存在左右子节点,直接加入队列,不用担心层次,
          //因为queueLen记录了当层节点数,出完了就进行下一层的遍历了
            node.left&&queue.push(node.left)
            node.right&&queue.push(node.right)
        }
        res.push(curlevel);
    }
    return res;
};
```



## [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {//BFS只加入右节点,队列每次只出一个
    if(root==null) return [];
    let queue=[];//总队列
    let res=[];
    queue.push(root);
    //队列每次只出一个 不需要计数
    while(queue.length){
        let node =queue.shift();
        res.push(node.val);
        node.right&&queue.push(node.right);
    }
    return res;
};
```



## [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

看清题意,二叉树右视图 只需要把每一层最后一个节点存储到res数组

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {//二叉树右视图 只需要把每一层最后一个节点存储到res数组
    if(root==null) return [];
    let queue=[];//总队列
    queue.push(root);
    
    let res=[];
    
    while(queue.length){
        let queueLen=queue.length;
        while(queueLen--){
            let node=queue.shift()
            if(queueLen==0){
                res.push(node.val)//每层的最后一个
            }
            node.left&&queue.push(node.left);
            node.right&&queue.push(node.right);
    }
        }

    return res;
};
```



## [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

102 求每层平均值

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var averageOfLevels = function(root) {//非空二叉树的
    let queue=[],res=[];
    queue.push(root);
    while(queue.length){
        let len=queue.length;
        let curSum=0;
        for(let i=0;i<len;i++){
            let node=queue.shift();
            curSum+=node.val;
            node.left&&queue.push(node.left);
            node.right &&queue.push(node.right);
        }
        res.push(curSum/len);
    }
    return res;
};
```



## [429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

每一层可能有2个以上,所以不再使用node.left node.right  而是循坏node.children

```js
/**
 * // Definition for a Node.
 * function Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

/**
 * @param {Node|null} root
 * @return {number[][]}
 */
var levelOrder = function(root) {// //每一层可能有2个以上,所以不再使用node.left node.right
    if(root==null) return [];
    let queue=[];
    let res=[];
    queue.push(root);
    while(queue.length){
        let len=queue.length;
        let curLevel=[];
        while(len--){
            let node=queue.shift();
            curLevel.push(node.val);
            //这里不再是 ndoe.left node.right 而是循坏node.children
            for(const item of node.children){
                item&&queue.push(item)
            }
        }
        res.push(curLevel);
    }
    return res;
};
```



## [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var largestValues = function(root) {//BFS
if(root==null) return [];
    let queue=[];
    let res=[];
    queue.push(root);
    while(queue.length){
        let len=queue.length;
        let max=-Infinity;
        while(len--){
            let node=queue.shift();
            max=Math.max(max,node.val);

            node.left&&queue.push(node.left);
            node.right&&queue.push(node.right);
        }
        res.push(max);
    }
    return res;
};
```



## [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

```js
/**
 * // Definition for a Node.
 * function Node(val, left, right, next) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.next = next === undefined ? null : next;
 * };
 */

/**
 * @param {Node} root
 * @return {Node}
 */
var connect = function(root) {
    if(root==null) return root;
    let queue=[];
    queue.push(root);
    while(queue.length){
        let len=queue.length;
        for(let i=0;i<len;i++){
            let node=queue.shift();
            ////初始状态下，所有 next 指针都被设置为 NULL。 最右本身就->null不用管
            if(i<len-1)node.next=queue[0];
            //[0,1,2]0先被shift,queue变成[1,2],想让0指向右边的1,让他=queue[0]
            node.left&&queue.push(node.left);
            node.right&&queue.push(node.right);

        }
    }
    return root;
};
```



## [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

```js
/**
 * // Definition for a Node.
 * function Node(val, left, right, next) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.next = next === undefined ? null : next;
 * };
 */

/**
 * @param {Node} root
 * @return {Node}
 */
var connect = function(root) {
    if(root==null) return root;
    let queue=[];
    queue.push(root);
    while(queue.length){
        let len=queue.length;
        for(let i=0;i<len;i++){
            let node=queue.shift();
            if(i<len-1) node.next=queue[0]//如果queue[0]不存在,也是null
            
            node.left&&queue.push(node.left);
            node.right&&queue.push(node.right);
        }
    }
    return root;
};
```



## [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

**DFS递归**

```js
var maxDepth = function(root) {
    const dfs=(node)=>{
        if(node==null) return 0;
        return Math.max(dfs(node.left),dfs(node.right))+1;
    }
    return dfs(root);
};
```

**BFS**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {//BFS
   if(root==null) return 0;
    let queue=[];
    let depth=0;
    queue.push(root);
    while(queue.length){
        let len=queue.length;
        for(let i=0;i<len;i++){
            let node=queue.shift();
            
            node.left&&queue.push(node.left);
            node.right&&queue.push(node.right);
        }
        depth++;
    }
    return depth;

};
```





## [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)



**BFS**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if(root==null) return 0;
    let queue=[];
    let depth=0;
    queue.push(root);
    while(queue.length){
        let len=queue.length;
        depth++;
        while(len--){
            let node=queue.shift();
            // // 如果左右节点都是null，则该节点深度最小
            if(node.left==null&&node.right==null) return depth;
            node.left&&queue.push(node.left);
            node.right&&queue.push(node.right);
        }
    }
    return depth;//这里随便返回啥都行,不会运行到这的
};
```

**DFS遍历**

代码简单不太好思考,不如BFS

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    const dfs=(node)=>{
        if(node==null) return 0;
        if(node.left==null&&node.right==null){//都不存在,到底了
            return 1;
        }else if(node.left&&node.right==null){//左节点存在
            return dfs(node.left)+1;
        }else if(node.left==null&&node.right){//右节点存在
            return dfs(node.right)+1;
        }else if(node.left&&node.right){//都存在
            return Math.min(dfs(node.left),dfs(node.right))+1;
        }
    }
    return dfs(root);
};
```

