# 二叉树

## 基础

![二叉树大纲](https://img-blog.csdnimg.cn/20210219190809451.png)



## [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

### 递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    let res=[];
    const dfs=(root)=>{
        if(root==null) return;
        res.push(root.val);//先序遍历
        dfs(root.left);
        dfs(root.right);
    }
    dfs(root);
    return res;
};
```

### 迭代

前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后**将右孩子加入栈，再加入左孩子,这样出栈的时候才是中左右的顺序**。

![二叉树前序遍历（迭代法）](https://tva1.sinaimg.cn/large/008eGmZEly1gnbmss7603g30eq0d4b2a.gif)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    let res=[];
    if(!root) return res;
    const stack=[];
    stack.push(root);//根节点进栈
    while(stack.length){
        let cur=stack.pop()//中间节点出栈
        res.push(cur.val);
        cur.right&&stack.push(cur.right);//右入栈
        cur.left&&stack.push(cur.left);//左入栈
    }
    return res;
};
```

前序遍历，发现取出一个栈顶元素，使其局部前序入栈后，栈顶元素依然是此元素，接着就要出栈输出了，所以使其随局部入栈是没有必要的

## [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

### 递归

```js
		const dfs=(root)=>{
        if(root==null) return;
        dfs(root.left);
        dfs(root.right);
        res.push(root.val);//后序遍历
    }
```

### 迭代

(在前序基础上修改)

先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：

![20200808200338924](https://img-blog.csdnimg.cn/20200808200338924.png)

```js

var postorderTraversal = function(root) {
let res=[];
    if(!root) return res;
    const stack=[];
    stack.push(root);//根节点进栈
    while(stack.length){
        let cur=stack.pop()//中间节点出栈
        res.push(cur.val);
        cur.left&&stack.push(cur.left);//左入栈  //颠倒顺序, 中右左
        cur.right&&stack.push(cur.right);//右入栈 
        
    }
    return res.reverse(); //翻转变成左右中
};
```



## [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

### 递归

```js
		const dfs=(root)=>{
        if(root==null) return;
        dfs(root.left);
        res.push(root.val);//中序遍历
        dfs(root.right);
    }
```

### 迭代

(与前后序处理方式不一致 )

中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**

那么**在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。**

![二叉树中序遍历（迭代法）](https://tva1.sinaimg.cn/large/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    let res=[];
    let stack=[];
    let cur=root;
    while(cur!=null||stack.length!=0){
        if(cur!==null){
            stack.push(cur);
            cur=cur.left;//左节点
        }else{//到底了
            cur=stack.pop();//弹出 中
            res.push(cur.val);//cur.val
            cur=cur.right;//右
        }
    }
    return res
};
```

## 144 145 95 统一格式迭代

*非递归遍历统一格式**https://blog.csdn.net/qq_36459536/article/details/80385886*

**将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**

如何标记呢，**就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。**

![中序遍历迭代（统一写法）](https://tva1.sinaimg.cn/large/008eGmZEly1gnbmq3btubg30em09ue82.gif)

可以看出我们将访问的节点直接加入到栈中，但如果**是处理的节点则后面放入一个空节点**， **这样只有空节点弹出的时候，才将下一个节点放进结果集。**

> 中序遍历统一迭代法

```js
//  中序遍历：左中右
//  压栈顺序：右中左
 
var inorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {
            res.push(stack.pop().val);
            continue;
        }
        if (node.right) stack.push(node.right); // 右
        stack.push(node); // 中
        stack.push(null);
        if (node.left) stack.push(node.left); // 左
    };
    return res;
};
```

> 前序遍历统一迭代法

```js
// 前序遍历：中左右
// 压栈顺序：右左中

var preorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {//node==null
            res.push(stack.pop().val);
            continue;
        }
        if (node.right) stack.push(node.right); // 右
        if (node.left) stack.push(node.left); // 左
        stack.push(node); // 中
        stack.push(null);
    };
    return res;
};
```



> 后序遍历统一迭代法

```js
// 后续遍历：左右中
// 压栈顺序：中右左
 
var postorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {
            res.push(stack.pop().val);
            continue;
        }
        stack.push(node); // 中
        stack.push(null);
        if (node.right) stack.push(node.right); // 右
        if (node.left) stack.push(node.left); // 左
    };
    return res;
};
```

