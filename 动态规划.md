# 动态规划

## 基础

### 动态规划的解题步骤

做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目AC之后，都不太清楚dp[i]表示的是什么。

**这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中**。

**状态转移公式（递推公式）**是很重要，但动规不仅仅只有递推公式。

**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**

1. **确定dp数组（dp table）以及下标的含义**
2. **确定递推公式**
3. **dp数组如何初始化**
4. **确定遍历顺序**
5. **举例推导dp数组**

一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？

**因为一些情况是递推公式决定了dp数组要如何初始化！**

后面的讲解中我都是围绕着这五点来进行讲解。

可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。

其实 确定递推公式 仅仅是解题里的一步而已！

一些同学知道递推公式，但搞不清楚dp数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。

后序的讲解的大家就会慢慢感受到这五步的重要性了。

### 动态规划应该如何debug

相信动规的题目，很大部分同学都是这样做的。

看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp数组的初始化，递推公式，遍历顺序，处于一种黑盒的理解状态。

写动规题目，代码出问题很正常！

**找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！**

一些同学对于dp的学习是黑盒的状态，就是不清楚dp数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。

这是一个很不好的习惯！

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。

如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。

如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

**这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了**。

这也是我为什么在动规五步曲里强调推导dp数组的重要性。

举个例子哈：在「代码随想录」刷题小分队微信群里，一些录友可能代码通过不了，会把代码抛到讨论群里问：我这里代码都已经和题解一模一样了，为什么通过不了呢？

发出这样的问题之前，其实可以自己先思考这三个问题：

- 这道题目我**举例推导状态转移公式**了么？
- 我**打印dp数组的日志**了么？
- **打印出来了dp数组和我想的一样么？**

**如果这灵魂三问自己都做到了，基本上这道题目也就解决了**，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历dp数组的顺序。



## [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

动规五部曲：

这里我们要用一个一维dp数组来保存递归的结果

1确定dp数组以及下标的含义

dp[i]的定义为：第i个数的斐波那契数值是dp[i]

2确定递推公式

为什么这是一道非常简单的入门题目呢？

**因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];**

3.dp数组如何初始化

**题目中把如何初始化也直接给我们了，如下：**

```text
dp[0] = 0;
dp[1] = 1;
```



4.确定遍历顺序

从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定**是从前到后**遍历的

5.举例推导dp数组

按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：

0 1 1 2 3 5 8 13 21 34 55

如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。

**动态规划**

```js
/**
 * @param {number} n
 * @return {number}
 */
var fib = function(n) {
    if(n<=1) return n;
    let dp=[];
    dp[0]=0,dp[1]=1;
    for(i=2;i<=n;i++){
        dp[i]=dp[i-1]+dp[i-2];
    }
    return dp[n];
};
```

只维护两个数值

```js
/**
 * @param {number} n
 * @return {number}
 */
var fib = function(n) {
    if(n<=1) return n;
    let dp=new Array(2);
    dp[0]=0,dp[1]=1;
    for(i=2;i<=n;i++){
        let sum=dp[0]+dp[1];
        dp[0]=dp[1];
        dp[1]=sum;
    }
    return dp[1];
};
```

**递归**

```js
/**
 * @param {number} n
 * @return {number}
 */
var fib = function(n) {
    if(n<2) return n;//F(0) = 0，F(1) = 1
    return fib(n-1)+fib(n-2);
};
```



## [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

本题大家如果没有接触过的话，会感觉比较难，多举几个例子，就可以发现其规律。

爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。

那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。

所以到**第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来**，那么就可以想到动态规划了。

**第n个台阶只能从第n-1或者n-2个上来。到第n-1个台阶的走法 + 第n-2个台阶的走法 = 到第n个台阶的走法**

我们来分析一下，动规五部曲：

定义一个一维数组来记录不同楼层的状态

1. 确定dp数组以及下标的含义

dp[i]： 爬到第i层楼梯，有dp[i]种方法

2.确定递推公式

如果可以推出dp[i]呢？

从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。

首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。

还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。

那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！

所以dp[i] = dp[i - 1] + dp[i - 2] 。

在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。

这体现出确定dp数组以及下标的含义的重要性！

3.dp数组如何初始化

在回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]中方法。

从dp数组定义的角度上来说，dp[0] = 0 也能说得通。

需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。

所以本题其实就不应该讨论dp[0]的初始化！

**dp[1] = 1，dp[2] = 2**，这个初始化大家应该都没有争议的。

所以我的原则是：不考虑dp[0]如果初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。

4.确定遍历顺序

从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的

5.举例推导dp数组

举例当n为5的时候，dp table（dp数组）应该是这样的

![70.爬楼梯](https://img-blog.csdnimg.cn/20210105202546299.png)

如果代码出问题了，就把dp table 打印出来，看看究竟是不是和自己推导的一样。

**此时大家应该发现了，这不就是斐波那契数列么！**

唯一的区别是，没有讨论dp[0]应该是什么，因为dp[0]在本题没有意义！

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if(n<=2) return n;
    let dp=[];
    dp[1]=1,dp[2]=2;
    for(let i=3;i<=n;i++){
        dp[i]=dp[i-1]+dp[i-2];
    }
    return dp[n];
};
```

**优化**

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if(n<=2) return n;
    let dp=new Array(2);
    dp[1]=1,dp[2]=2;
    for(let i=3;i<=n;i++){
        let tmp=dp[1]+dp[2];
        dp[1]=dp[2];
        dp[2]=tmp;
    }
    return dp[2];
};
```

### 拓展:一步可以爬m级台阶

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    let dp=new Array(n+1).fill(0);
    let m=2
    dp[0]=1;
    for(let i=1;i<=n;i++){
        for(let j=1;j<=m;j++){
            if(i-j>=0) dp[i]+=dp[i-j];
        }

    }
    return dp[n];
};
```



## [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

这道题目，刚一看最直观的想法就是用图论里的深搜，来枚举出来有多少种路径。

注意题目中说机器人每次只能向下或者向右移动一步，那么其实**机器人走过的路径可以抽象为一棵二叉树，而叶子节点就是终点！**

如图举例：

![62.不同路径](https://img-blog.csdnimg.cn/20201209113602700.png)

此时问题就可以转化为求二叉树叶子节点的个数，代码如下：

DFS(超时) 可以**用记忆化**

```js
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
    const DFS=(mm,nn)=>{
        if(mm>m||nn>n) return 0;//越界
        if(mm==m&&nn==n) return 1;//找到终点

        return DFS(mm+1,nn)+DFS(mm,nn+1);
    }
    return DFS(1,1);
};
```

**动态规划**

机器人从(0 , 0) 位置出发，到(m - 1, n - 1)终点。

按照动规五部曲来分析：

1.确定dp数组（dp table）以及下标的含义

dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。

2.确定递推公式

```
想要求dp[i][j]，只能有两个方向来推导出来，即dp[i - 1][j] 和 dp[i][j - 1]。
此时在回顾一下 dp[i - 1][j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。

那么很自然，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。
```

3.dp数组的初始化

只能向下或者向右移动一步

如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。

所以初始化代码为：

```js
    for(let i=0;i<m;i++) dp[i][0]=1;
    for(let j=0;j<n;j++) dp[0][j]=1;
```



4.确定遍历顺序

```
这里要看一下递归公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。

这样就可以保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值的。
```



5.举例推导dp数组

如图所示：

![62.不同路径1](https://img-blog.csdnimg.cn/20201209113631392.png)

```js
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
    let dp = Array(m).fill().map(item => Array(n))
    for(let i=0;i<m;i++) dp[i][0]=1;
    for(let j=0;j<n;j++) dp[0][j]=1;
    for(let i=1;i<m;i++){
        for(let j=1;j<n;j++){
            dp[i][j]= dp[i-1][j]+ dp[i][j-1];
        }
    }
    return  dp[m-1][n-1]

};
```



## [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

这道题相对于[62.不同路径 (opens new window)](https://programmercarl.com/0062.不同路径.html)就是有了障碍。

第一次接触这种题目的同学可能会有点懵，这有障碍了，应该怎么算呢？

[62.不同路径 (opens new window)](https://programmercarl.com/0062.不同路径.html)中我们已经详细分析了没有障碍的情况，有障碍的话，其实就是标记对应的dp table（dp数组）保持初始值(0)就可以了。

动规五部曲：

1.确定dp数组（dp table）以及下标的含义

```
dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。
```

2.确定递推公式

```
递推公式和62.不同路径一样，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]。
```

但这里需要注意一点，**因为有了障碍，(i, j)如果就是障碍的话应该就保持初始状态（初始状态为0）。**

所以代码为：

```text
if (obstacleGrid[i][j] == 0) { // 当(i, j)没有障碍的时候，再推导dp[i][j]
    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
}
```



3.dp数组如何初始化

在[62.不同路径 (opens new window)](https://programmercarl.com/0062.不同路径.html)不同路径中我们给出如下的初始化：

```text
vector<vector<int>> dp(m, vector<int>(n, 0)); // 初始值为0
for (int i = 0; i < m; i++) dp[i][0] = 1;
for (int j = 0; j < n; j++) dp[0][j] = 1;
```



```
因为从(0, 0)的位置到(i, 0)的路径只有一条，所以dp[i][0]一定为1，dp[0][j]也同理。
但如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的dp[i][0]应该还是初始值0。
```

如图：

![63.不同路径II](https://img-blog.csdnimg.cn/20210104114513928.png)

下标(0, j)的初始化情况同理。

**所以本题初始化代码为：**

```js
let dp=new Array(m).fill(0).map(item=>new Array(n).fill(0));
for(let i=0;i<m&&obstacleGrid[i][0]==0;i++) dp[i][0]=1;
for(let j=0;j<n&&obstacleGrid[0][j]==0;j++) dp[0][j]=1;
```

```
注意代码里for循环的终止条件，一旦遇到obstacleGrid[i][0] == 1的情况就停止dp[i][0]的赋值1的操作，dp[0][j]同理**
```

4.确定遍历顺序

```
从递归公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1] 中可以看出，一定是从左到右一层一层遍历，这样保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值。
```

代码如下：

```cpp
    for(let i=1;i<m;i++){
         for(let j=1;j<n;j++){
             if(obstacleGrid[i][j]) continue;
             dp[i][j]=dp[i-1][j]+dp[i][j-1];
         }
    }
```



5.举例推导dp数组

拿示例1来举例如题：

![63.不同路径II1](https://img-blog.csdnimg.cn/20210104114548983.png)

对应的dp table 如图：

![63.不同路径II2](https://img-blog.csdnimg.cn/20210104114610256.png)

```js
/**
 * @param {number[][]} obstacleGrid
 * @return {number}
 */
var uniquePathsWithObstacles = function(obstacleGrid) {
    let m=obstacleGrid.length;
    let n=obstacleGrid[0].length;
    let dp=new Array(m).fill(0).map(item=>new Array(n).fill(0));
    for(let i=0;i<m&&obstacleGrid[i][0]==0;i++) dp[i][0]=1;
    for(let j=0;j<n&&obstacleGrid[0][j]==0;j++) dp[0][j]=1;
    
    for(let i=1;i<m;i++){
         for(let j=1;j<n;j++){
             if(obstacleGrid[i][j] == 1) continue;
             dp[i][j]=dp[i-1][j]+dp[i][j-1];
         }
    }
    return dp[m-1][n-1];
};
```



## [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

动规五部曲，分析如下：

1. 确定dp数组（dp table）以及下标的含义

dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。

dp[i]的定义讲贯彻整个解题过程，下面哪一步想不懂了，就想想dp[i]究竟表示的是啥！

2.确定递推公式

可以想 dp[i]最大乘积是怎么得到的呢？

其实可以从1遍历j，然后有两种渠道得到dp[i].

一个是**j * (i - j)** 直接相乘。

一个是**j * dp[i - j]**，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。

**那有同学问了，j怎么就不拆分呢？**

j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。

那么从1遍历j，比较(i - j) * j和dp[i - j] * j 取最大的。递推公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));

也可以这么理解**，j * (i - j) 是单纯的把整数拆分为两个数相乘，**

**而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。**

如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了。

所以递推公式：**dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j});**

**那么在取最大值的时候，为什么还要比较dp[i]呢？**

- 因为在递推公式推导的过程中，每次计算dp[i]，取最大的而已。

3.dp的初始化

不少同学应该疑惑，dp[0] dp[1]应该初始化多少呢？

有的题解里会给出dp[0] = 1，dp[1] = 1的初始化，但解释比较牵强，主要还是因为这么初始化可以把题目过了。

严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。

拆分0和拆分1的最大乘积是多少？

这是无解的。

这里我**只初始化dp[2] = 1**，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！

4.确定遍历顺序

确定遍历顺序，先来看看递归公式：**dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));**

**dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。**

**枚举j的时候，是从1开始的。i是从3开始**，这样dp[i - j]就是dp[2]正好可以通过我们初始化的数值求出来。

所以遍历顺序为：

```js
    for(let i=3;i<=n;i++){
        for(let j=1;j<i-1;j++){
            dp[i]=Math.max(dp[i],Math.max((i-j)*j,dp[i-j]*j));
        }
    }
```



5.举例推导dp数组

举例当n为10 的时候，dp数组里的数值，如下：

![343.整数拆分](https://img-blog.csdnimg.cn/20210104173021581.png)

```js
/**
 * @param {number} n
 * @return {number}
 */
var integerBreak = function(n) {
    let dp=new Array(n+1).fill(0);
    dp[2]=1;
    for(let i=3;i<=n;i++){
        for(let j=1;j<i-1;j++){
            dp[i]=Math.max(dp[i],Math.max((i-j)*j,dp[i-j]*j));
        }
    }
    return dp[n];
};
```



## [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)



如图：

![96.不同的二叉搜索树](https://img-blog.csdnimg.cn/20210107093106367.png)

n为1的时候有一棵树，n为2有两棵树，这个是很直观的。

![96.不同的二叉搜索树1](https://img-blog.csdnimg.cn/20210107093129889.png)

来看看n为3的时候，有哪几种情况。

当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，是不是和 n 为2的时候两棵树的布局是一样的啊！

（可能有同学问了，这布局不一样啊，节点数值都不一样。别忘了我们就是求不同树的数量，并不用把搜索树都列出来，所以不用关心其具体数值的差异）

当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，是不是和n为2的时候两棵树的布局也是一样的啊！

当2为头结点的时候，其左右子树都只有一个节点，布局是不是和n为1的时候只有一棵树的布局也是一样的啊！

发现到这里，其实我们就找到了重叠子问题了，其实也就是发现可以通过dp[1] 和 dp[2] 来推导出来dp[3]的某种方式。

思考到这里，这道题目就有眉目了。

dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

有2个元素的搜索树数量就是dp[2]。

有1个元素的搜索树数量就是dp[1]。

有0个元素的搜索树数量就是dp[0]。

所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]

如图所示：

![96.不同的二叉搜索树2](https://img-blog.csdnimg.cn/20210107093226241.png)

此时我们已经找到递推关系了，那么可以用动规五部曲再系统分析一遍。

1.确定dp数组（dp table）以及下标的含义

**dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。

也可以理解是i的不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。

以下分析如果想不清楚，就来回想一下dp[i]的定义

2.确定递推公式

在上面的分析中，其实已经看出其递推关系:

 **dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]**

j相当于是头结点的元素，从1遍历到i为止。

所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，

**j-1 为j为头结点左子树节点数量**，**i-j 为以j为头结点右子树节点数量**

3.dp数组如何初始化

初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。

那么dp[0]应该是多少呢？

从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。

从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。

所以初始化dp[0] = 1

4.确定遍历顺序

首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。

那么遍历i里面每一个数作为头结点的状态，用j来遍历。

代码如下：

```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
        dp[i] += dp[j - 1] * dp[i - j];
    }
}
```



5.举例推导dp数组

n为5时候的dp数组状态如图：

![96.不同的二叉搜索树3](https://img-blog.csdnimg.cn/20210107093253987.png)

当然如果自己画图举例的话，基本举例到n为3就可以了，n为4的时候，画图已经比较麻烦了。

```js
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function(n) {
    let dp=new Array(n+1).fill(0);
    dp[0]=1;
    dp[1]=1;
    for(let i=2;i<=n;i++){
        for(let j=1;j<=i;j++){
            dp[i]+=dp[j-1]*dp[i-j];
        }
    }
    return dp[n];
};
```

