# 栈与队列

## 基础

- 栈FILO
- 队列FIFO

## [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

### 思路

![232.用栈实现队列版本2](https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif)

- 在push数据的时候，只要数据放进输入栈就好，
- **但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）**，再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。

- 最后如何判断队列为空呢？**如果进栈和出栈都为空的话，说明模拟的队列为空了。**



```js
var MyQueue = function() {
    this.stackIn=[];
    this.stackOut=[];
};

/** 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
    this.stackIn.push(x);
};

/**
 * @return {number}
 */
MyQueue.prototype.pop = function() {
    //stackOut不为空就直接返回
    if(this.stackOut.length>0){
        return this.stackOut.pop();
    }
    //stackOut为空 把进栈数据全部导入输出栈
    while(this.stackIn.length>0){
        this.stackOut.push(this.stackIn.pop());
    }
    return this.stackOut.pop();
};

/**
 * @return {number}
 */
MyQueue.prototype.peek = function() {
    //返回队列开头的元素
    const x=this.pop();//先取出队列开头元素,
    this.stackOut.push(x);//再还回去
    return x;
};

/**
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
    return this.stackOut.length===0&&this.stackIn.length===0;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
```



## [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

### 思路

**队列是先进先出的规则，把一个队列中的数据导入另一个队列中，数据的顺序并没有变，并没有变成先进后出的顺序。**

所以用栈实现队列， 和用队列实现栈的思路还是不一样的，这取决于这两个数据结构的性质。

**用两个队列que1和que2实现队列的功能，que2其实完全就是一个备份的作用**，把que1最后面的元素以外的元素都备份到que2，然后弹出最后面的元素，再把其他元素从que2导回que1。

![225.用队列实现栈](https://code-thinking.cdn.bcebos.com/gifs/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.gif)





```js
var MyStack = function() {
    //使用数组（push, shift）模拟队列 shift删除第一个值
    this.queue1=[];
    this.queue2=[];
};

/** 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
    this.queue1.push(x);
};

/**
 * @return {number}
 */
MyStack.prototype.pop = function() {
    if(this.queue1.length===0){// 减少两个队列交换的次数， 只有当queue1为空时，交换两个队列
        [[this.queue1,this.queue2]]=[[this.queue2,this.queue1]];
    }
    while(this.queue1.length>1){//q1只留一个
        this.queue2.push(this.queue1.shift());
    }
    return this.queue1.shift(); //移出
};

/**
 * @return {number}
 */
MyStack.prototype.top = function() {
    const x=this.pop();//取出来 再还回去
    this.queue1.push(x);
    return x;
};

/**
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    return this.queue1.length===0&&this.queue2.length===0;
};

/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */
```

**优化**

**一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。**

```js

var MyStack = function() { //shift删除首  push为尾插入
    this.queue=[];
};

/** 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
     this.queue.push(x);
};

/**
 * @return {number}
 */
MyStack.prototype.pop = function() {
    let  size=this.queue.length;
    while(size-->1){
        this.queue.push(this.queue.shift());//把除了最后1个都移出再重新加入到队尾,然后移出队首元素
    }
    return this.queue.shift();
};

/**
 * @return {number}
 */
MyStack.prototype.top = function() {
    const x=this.pop();
    this.queue.push(x);
    return x;
};

/**
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    return this.queue.length===0;
};

/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */
```

