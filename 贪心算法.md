# 贪心算法

![贪心算法大纲](https://code-thinking-1253855093.file.myqcloud.com/pics/20210917104315.png)

**贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。

贪心算法一般分为如下四步：

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

其实这个分的有点细了，真正做题的时候很难分出这么详细的解题步骤，可能就是因为贪心的题目往往还和其他方面的知识混在一起。



## [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

为了满足更多的小孩，就不要造成饼干尺寸的浪费。

大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。

**这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩**。

可以尝试使用贪心策略，先将饼干数组和小孩数组排序。

然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。

如图：

![455.分发饼干](https://img-blog.csdnimg.cn/20201123161809624.png)

**大饼干优先满足胃口大的**

```js
/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
var findContentChildren = function(g, s) {
    g.sort((a, b) => a - b);//升序
    s.sort((a, b) => a - b);
    let res=0
    let sIndex=s.length-1;//饼干数组下标
    for(let i=g.length-1;i>=0;i--){
        if(sIndex>=0&&s[sIndex]>=g[i]){
            res++;
            sIndex--;
        }
    }
    return res;
};
```

**小饼干先喂饱小胃口**

```js
/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
var findContentChildren = function(g, s) {
    g.sort((a, b) => a - b);
    s.sort((a, b) => a - b);
    let gIndex=0;//胃口数组下标
    for(let i=0;i<=s.length-1;i++){
        if(gIndex<g.length&&g[gIndex]<=s[i]){
            gIndex++;
        }
    }
    return gIndex;
};
```



## [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

分析一下，要求删除元素使其达到**最大摆动序列**，应该删除什么元素呢？

用示例二来举例，如图所示：

![376.摆动序列](https://img-blog.csdnimg.cn/20201124174327597.png)

**局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值**。

**整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列**。

局部最优推出全局最优，并举不出反例，那么试试贪心！

（为方便表述，以下说的峰值都是指局部峰值）

**实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）**

**这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点**。

本题代码实现中，还有一些技巧，例如统计峰值的时候，数组最左面和最右面是最不好统计的。

例如序列[2,5]，它的峰值数量是2，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。

所以可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即preDiff = 0，如图：

![376.摆动序列1](https://img-blog.csdnimg.cn/20201124174357612.png)

针对以上情形，result初始为1（默认最右面有一个峰值），此时curDiff > 0 && preDiff <= 0，那么result++（计算了左面的峰值），最后得到的result就是2（峰值个数为2即摆动序列长度为2）

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var wiggleMaxLength = function(nums) {
    if(nums.length<=1) return nums.length;
    let res=1; // 记录峰值个数，序列默认序列最右边有一个峰值
    let preDiff=0; // 前一对差值
    let curDiff=0; // 当前一对差值

    for(let i=0;i<nums.length-1;i++){
        curDiff=nums[i+1]-nums[i];
        if(curDiff>0&&preDiff<=0||curDiff<0&&preDiff>=0){
            res++;
            preDiff=curDiff;
        }
    }
    return res;
};
```



## [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

如果 -2 1 在一起，计算起点的时候，一定是从1开始计算，**因为负数只会拉低总和，**这就是贪心贪的地方！

局部最优：**当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。**

全局最优：选取最大“连续和”

**局部最优的情况下，并记录最大的“连续和”，可以推出全局最优**。

从代码角度上来讲：遍历nums，从头开始用count累积，如果count一旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let maxSum=-Infinity;
    let count=0;
    for(let i=0;i<nums.length;i++){
        count+=nums[i];
        maxSum=count>maxSum?count:maxSum;//记录最大值
        if(count<=0) count=0;//相当于重置最大子序起始位置 因为遇到负数一定是拉低总和
    }  
    return maxSum;
};
```



## [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)



这道题目可能我们只会想，选一个低的买入，在选个高的卖，在选一个低的买入.....循环反复。

**如果想到其实最终利润是可以分解的，那么本题就很容易了！**

如何分解呢？

假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。

相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。

**此时就是把利润分解为每天为单位的维度，而不是从0天到第3天整体去考虑！**

那么根据prices可以得到每天的利润序列：(prices[i] - prices[i - 1]).....(prices[1] - prices[0])。

如图：

![122.买卖股票的最佳时机II](https://img-blog.csdnimg.cn/2020112917480858.png)

一些同学陷入：第一天怎么就没有利润呢，第一天到底算不算的困惑中。

第一天当然没有利润，至少要第二天才会有利润，所以利润的序列比股票序列少一天！

从图中可以发现，其实我们需要收集每天的正利润就可以，**收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间**。

那么只收集正利润就是贪心所贪的地方！

**局部最优：收集每天的正利润，全局最优：求得最大利润**。

- 遍历整个股票交易日价格列表 `price`，策略是所有上涨交易日都买卖（赚到所有利润），所有下降交易日都不买卖（永不亏钱）。

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    let res=0;
    for(let i=0;i<prices.length-1;i++){
        res+=Math.max(0,prices[i+1]-prices[i])//只收集正的
    }
    return res;
};
```

